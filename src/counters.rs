use leptos::*;
use leptos_meta::*;
use leptos_router::*;

#[cfg(feature = "ssr")]
pub mod ssr_imports {
    pub use broadcaster::BroadcastChannel;
    pub use std::sync::atomic::{AtomicI32, Ordering};

    pub static COUNT: AtomicI32 = AtomicI32::new(0);

    lazy_static::lazy_static! {
        pub static ref COUNT_CHANNEL: BroadcastChannel<i32> = BroadcastChannel::new();
    }
}

#[server]
pub async fn get_server_count() -> Result<i32, ServerFnError> {
    use ssr_imports::*;

    Ok(COUNT.load(Ordering::Relaxed))
}

#[server]
pub async fn adjust_server_count(delta: i32, msg: String) -> Result<i32, ServerFnError> {
    use ssr_imports::*;

    let new = COUNT.load(Ordering::Relaxed) + delta;
    COUNT.store(new, Ordering::Relaxed);
    _ = COUNT_CHANNEL.send(&new).await;
    println!("message = {msg}");
    Ok(new)
}

#[server]
pub async fn clear_server_count() -> Result<i32, ServerFnError> {
    use ssr_imports::*;

    COUNT.store(0, Ordering::Relaxed);
    _ = COUNT_CHANNEL.send(&0).await;
    Ok(0)
}

#[component]
pub fn Counters() -> impl IntoView {
    provide_meta_context();

    let subtitle = if cfg!(feature = "ssr") {
        "SSR only"
    } else if cfg!(feature = "hydrate") {
        "Hydrated SSR"
    } else {
        "CSR with proxy for server fns"
    };

    view! {
        <Router>
            <header>
                <h1>Trunk and Cargo Leptos</h1>
            </header>
            <div style="font-size: 2rem; font-weight: bold;">{subtitle}</div>
            
            <Link rel="shortcut icon" type_="image/ico" href="/favicon.ico"/>
            <main>
                <Routes>
                    <Route path="" view=FormCounter ssr=SsrMode::Async/>
                </Routes>
            </main>
        </Router>
    }
}

// This is the <Form/> counter
// It uses the same invalidation pattern as the plain counter,
// but uses HTML forms to submit the actions
#[component]
pub fn FormCounter() -> impl IntoView {
    // these struct names are auto-generated by #[server]
    // they are just the PascalCased versions of the function names
    let adjust = create_server_action::<AdjustServerCount>();
    let clear = create_server_action::<ClearServerCount>();

    let counter = create_resource(
        move || (adjust.version().get(), clear.version().get()),
        |_| get_server_count(),
    );
    let value = move || counter.get().and_then(|n| n.ok()).unwrap_or(0);

    view! {
        <div>
            <h2>Counter</h2>
            <p>
                This counter uses forms to set the value on the server.
                When run with cargo leptos, the form will be progressively enhanced and work both with and without javascript enabled.
                When run with trunk (still requires running cargo leptos in the background), the app will only use client-side rendering, but still send serverfn requests to the server. This allows server actions to work in all rendering modes.
            </p>
            <div>
                <ActionForm action=clear>
                    <input type="submit" value="Clear"/>
                </ActionForm>
                <ActionForm action=adjust>
                    <input type="hidden" name="delta" value="-1"/>
                    <input type="hidden" name="msg" value="form value down"/>
                    <input type="submit" value="-1"/>
                </ActionForm>
                <span>"Value: " <Suspense>{move || value().to_string()} "!"</Suspense></span>
                <ActionForm action=adjust>
                    <input type="hidden" name="delta" value="1"/>
                    <input type="hidden" name="msg" value="form value up"/>
                    <input type="submit" value="+1"/>
                </ActionForm>
            </div>
        </div>
    }
}
